# Сборник гайдов по Skript - единый файл (Markdown)

---

## Оглавление

1. [Введение - что такое Skript и зачем он нужен](#введение---что-такое-skript-и-зачем-он-нужен)
2. [Основы синтаксиса: отступы, блоки, комментарии](#основы-синтаксиса-отступы-блоки-комментарии)
3. [Триггеры и события (events) - как Skript реагирует на мир](#триггеры-и-события-events---как-skript-реагирует-на-мир)
4. [Переменные и типизация - в чем особенности и аналоги](#переменные-и-типизация---в-чем-особенности-и-аналоги)
5. [Условия (if / else) - ветвления и логика](#условия-if--else---ветвления-и-логика)
6. [Циклы и управление потоком - loop, while, repeat](#циклы-и-управление-потоком---loop-while-repeat)
7. [Функции и пользовательские конструкции - структурирование кода](#функции-и-пользовательские-конструкции---структурирование-кода)
8. [Команды (commands) - как создавать команды для игроков](#команды-commands---как-создавать-команды-для-игроков)
9. [Выражения, операции и математические аналоги](#выражения-операции-и-математические-аналогии)
10. [Работа с игроками и игровым миром (локации, предметы, сущности)](#работа-с-игроками-и-игровым-миром-локации-предметы-сущности)
11. [Отладка, производительность и лучшие практики](#отладка-производительность-и-лучшие-практики)
12. [Краткие примеры: готовые мини-скрипты и сравнения с Python](#краткие-примеры-готовые-мини-скрипты-и-сравнения-с-python)

P.S. также рекомендуется прочитать [гайд на английском языке](https://sovdee.gitbook.io/skript-tutorials "гайд на английском языке"), все что есть тут частично взято оттуда.

---

# Введение - что такое Skript и зачем он нужен

**Skript** - это плагин/DSL-язык, предназначенный для быстрого написания игровой логики для серверов Minecraft (Spigot/Paper). Главная идея Skript - позволить администраторам и скриптерам создавать «мини-плагины» без знания Java: вместо компиляции и API-интеграции вы пишете человеческо-понятные текстовые скрипты, которые интерпретируются плагином. Skript ориентирован на **событийно-ориентированное** программирование: код выполняется в ответ на игровые события (вход игрока, разрушение блока, чат и т. п.).

Почему Skript удобен:

* низкий порог входа - синтаксис похож на псевдо-английский;
* быстрота разработки - правка файла `.sk` и перезагрузка через `/sk reload (файл).sk` обычно достаточно;
* хорош для прототипирования игровых механик, мини-игр, админ-инструментов;
* дружелюбен к тем, кто знает другие скриптовые языки (Python, JS): многие конструкции интуитивно понятны.

Кому полезен:

* администраторам серверов, которым нужно быстро сделать фичу;
* начинающим программистам - Skript помогает освоить базовые концепты (переменные, ветвления, циклы, события);
* опытным программистам - как быстрый способ прототипирования логики до её портирования в полноценный плагин на Java.
* тем кому банально лень писать на Java.

Ключевая особенность Skript - **императивно-реактивная** модель: нет «главной функции», нет постоянного цикла; всё - реакция на события. Это похоже на обработчики событий (event handlers) в GUI-программировании или на `@app.route` в web-фреймворках: вы описываете, что должно произойти когда.

---

# Основы синтаксиса: отступы, блоки, комментарии

Skript использует понятный и минималистичный синтаксис. Главное правило: **вложенность определяется отступами**, похожими на Python. Нет фигурных скобок или ключевых слов `begin/end` - после строки, заканчивающейся `:`, все последующие строки с большим отступом считаются частью блока.

Примеры ключевых синтаксических конструкций:

```skript
on join:
    send "Добро пожаловать, %player%!" to player

command /greet:
    trigger:
        send "Привет, %player%!" to player
```

* Строки, оканчивающиеся `:`, начинают блок (`on`, `command`, `if`, `loop`, `function` и т.д.).
* Следующая строка должна иметь **одинаковый** отступ (всегда используйте либо пробелы, либо табы, и не смешивайте).
* Комментарии начинаются с `#` и тянутся до конца строки:

  ```skript
  # Это комментарий
  send "Hello" to player  # комментарий можно и в конце строки
  ```

Примеры ошибок:

* смешение табов и пробелов (может привести к неожиданному поведению);
* отсутствие отступа после `:` (код не попадёт в блок);
* попытка использовать несколько событий в одном `on` (в Skript один `on` = одно событие).

Сравнение с Python: в обоих языках вложенность определяется отступами; отличие - в Skript много ключевых слов типа `on`, `command`, `loop`, и синтаксис настроен под игровую логику, а не универсальную программную задачу. Если вы привыкли к `{}` в C/Java, думайте о `:` + отступ как о той же самой группе инструкций.

Совет: поддерживайте единообразие в проекте - выберите стиль отступов (2 или 4 пробела) и придерживайтесь его. Это облегчает чтение и поддержку.

---

# Триггеры и события (events) - как Skript реагирует на мир

Skript - **событийно-ориентированный** язык. Это значит, что основная единица выполнения - **триггер** (trigger). Триггер - блок вида `on <событие>:` (или просто `<событие>:`) и описывает реакцию на конкретное событие в игре. События - вход игрока (`join`), выход (`quit`), чат (`chat`), ломание блока (`break block`), убийство (`death`), клики мыши (`right click`, `left click`) и множество других. Полный список зависит от версии Skript и подключённых аддонов, но базовые события покрывают большинство задач.

Пример базового обработчика:

```skript
on join:
    send "Добро пожаловать, %player%!" to player
    if player has permission "vip":
        send "Спасибо, VIP!" to player
```

Важные моменты:

* Внутри `on`-блока доступны контекстные переменные: `%player%`, `%event-player%`, `%event-location%` и т. п. (названия зависят от события).
* Один `on`-блок отвечает за одно событие - нельзя объединять разные типы событий в одной строке.
* Триггеры могут содержать условия, циклы и вызовы функций - они обычные блоки исполнения.
* События могут быть **перехвачены** (cancelled) в Skript, если событие поддерживает отмену. Например, `cancel event` отменит действие в игровом мире (например, предотвратит разрушение блока).

Математическая аналогия: представьте функции-обработчики f: E → A, где E — множество событий, а A — действия (effect). Каждый обработчик сопоставляет событие с набором действий; когда элемент e ∈ E «приходит», вызывается соответствующая функция.

Сравнение с другими языками:

* В Python с библиотеками для веба или GUI вы регистрируете обработчики (например, `@app.route` или `button.clicked.connect(handler)`). Skript - тот же паттерн, только применён к игровым событиям.
* В Java/Spigot API вы реализуете интерфейс `Listener` и аннотируете методы `@EventHandler` - Skript избавляет от Java-кода и делает это декларативным.

Практика:

* Используйте события для реактивных механик: приветствие, логирование, перехват действий игроков.
* Не делайте «тяжёлую» логику прямо в `on`-блоке - выносите в функции при повторном использовании.

---

# Переменные и типизация - в чем особенности и аналоги

Skript использует **динамическую** систему типов и удобную нотацию для переменных. Переменные обычно пишутся в фигурных скобках: `{name}`, `{player::uuid}`, `{homes::%player%}` и т.д. Есть различие между глобальными и локальными переменными: обычно локальные обозначают с нижним подчёркиванием `{_temp}` или в функциях используются параметры `_arg`. Список-переменные принято записывать как `{list::*}` (звёздочка приказывает Skript трактовать это как список).

Типы данных:

* **Примитивы**: `number` (число), `text` (строка), `boolean` (логическое значение).
* **Игровые типы**: `player`, `location`, `item`, `entity`, `block`, и т.п.
* **Списки**: `{list::*}` - динамический размер, элементы доступны по индексам `{list::1}`, `{list::2}`.
* **Неразложимые объекты**: например `inventory` или `player's inventory`.

Примеры:

```skript
set {_name} to "Alex"    # строка
set {_coins} to 42       # число
add 1 to {_coins}        # арифметика
set {users::%player%} to "online"  # ассоциативное (map-подобное) хранение
set {_items::*} to diamond, iron_ingot, torch  # список
```

Типизация в Skript - **нестрогая**: одно и то же имя переменной может в разное время хранить строку, число или объект; Skript будет пытаться подставлять и конвертировать в контексте выражений. Это похоже на Python, где переменные имеют тип, но он определяется динамически во время выполнения.

Математическая аналогия: переменная в Skript — это символ x в алгебре, которому в разный момент можно приписывать разные значения (число, вектор, множество). Списки — это вектор v = (v₁, v₂, …), где доступ к элементам осуществляется по индексу.

Особенности и подводные камни:

* Следите за именами переменных - `{x}` и `{_x}` - разные области видимости.
* Используйте списки `{list::*}` для коллекций - они удобны и читаемы.
* При работе с числами и строками Skript иногда выполняет автоматические преобразования - если ожидаете строгое поведение, явно кастуйте/форматируйте (например, `as integer` или `as text`, если аддон поддерживает).
* Для персистентного хранения используйте имена с уникальными ключами (uuid игрока) - `{homes::%player's uuid%}`.

Сравнение с Python:

* Python: `x = 5`, `x = "hello"` - точно так же.
* Skript: `set {x} to 5`, `set {x} to "hello"` - аналогично, но с синтаксисом, ориентированным на текстовые команды.

---

# Условия (if / else) - ветвления и логика

Ветвления в Skript выполняются через привычные `if`, `else if`, `else`. Синтаксис интуитивно понятен и ориентирован на читаемость:

```skript
if {_hp} < 5:
    send "Осталось мало здоровья!" to player
else if {_hp} < 10:
    send "Нужно быть осторожным." to player
else:
    send "Всё хорошо." to player
```

Особенности:

* Условия могут быть **инлайн**: `broadcast "Привет" if player has permission "vip"`. Это удобно для коротких проверок.
* Skript поддерживает логические связки `and`, `or`, а также отрицание `not`.
* Поддерживаются **цепочные сравнения**: `if 1 < {_x} < 10:` - что экономит запись и делает код ближе к математической нотации.
* Много встроенных предикатов: `player has permission`, `player is online`, `block is stone`, `entity is a zombie` и т.д. Это облегчает написание проверок, специфичных для Minecraft.

Пара примеров с контекстом события:

```skript
on damage of player:
    if attacker is player:
        if attacker has permission "can-hit":
            send "Вы нанесли урон!" to attacker
        else:
            cancel event
            send "У вас нет права атаковать игроков." to attacker
```

Советы по логике:

* Ставьте самое специфичное условие первым (оптимизация чтения и понятности).
* Если ветви длинные и повторяются, выносите общую часть в функцию - это уменьшает дублирование.
* Используйте `switch`-подобную структуру через `if`/`else if` при множественных вариантах.

Сравнение с Python:

* Python:

  ```python
  if x < 5:
      ...
  elif x < 10:
      ...
  else:
      ...
  ```
* Skript аналогичен по семантике, но написание ближе к естественному языку и игровой терминологии.

Математическая аналогия: условие - это разделение множества входных ситуаций (X) на подмножества (A, B, C) и выполнение разных функций на каждом подмножестве. `if` - проверка принадлежности элементу множества.

---

# Циклы и управление потоком - loop, while, repeat

Skript предоставляет несколько способов повторения действий: `loop` (итерация по коллекции), `while` (пока условие истинно), `loop N times` (повтор N раз), а также конструкции `stop`, `break`/`continue`-эквиваленты.

**Loop по коллекции**:

```skript
loop all players:
    send "Привет, %loop-player%!" to loop-player
```

При каждой итерации доступны специальные переменные: `loop-player`, `loop-index`, `loop-value` (в зависимости от контекста). `loop` можно применять к спискам, диапазонам блоков, сущностям, предметам и т.д.

**Loop N times**:

```skript
loop 5 times:
    give diamond to player
```

**While**:

```skript
set {_i} to 0
while {_i} < 10:
    add 1 to {_i}
    send "i = %{_i}%" to player
```

Осторожно: `while` может породить бесконечный цикл, если условие никогда не станет ложным.

**Управление потоком**:

* `stop` - прекратить выполнение текущего блока/функции;
* `break`/`continue` - в базовом Skript нет явных `break`/`continue`, но есть `stop` в сочетании с контрольными флагами и `if`-проверками; некоторые аддоны расширяют синтаксис.

Практические советы:

* Избегайте тяжёлых вычислений в циклах, особенно в `on`-обработчиках, чтобы не блокировать главный поток сервера.
* Для задач, которые должны выполняться асинхронно или повторяться с таймером, используйте `every` (периодические задачи):

  ```skript
  every 5 seconds:
      broadcast "5 секунд прошло!"
  ```
* При переборе больших коллекций (например, всех блоков в радиусе 100) думайте о производительности: лучше разбивать работу на шаги.

Сравнение с Python:

* Python имеет `for`/`while`/`break`/`continue`. Skript: `loop` ≈ `for`, `while` ≈ `while`, но меньшая выразительность низкоуровневых управляющих конструкций - это компромисс в пользу читабельности и простоты.

Математическая аналогия: `loop` - это суммирование/агрегация по конечному множеству ∑ (i ∈ I) f(i), а `while` - итеративная процедура, которая повторяется, пока выполняется условие (как итеративный метод в численных методах).

---

# Функции и пользовательские конструкции - структурирование кода

Функции в Skript позволяют выносить повторяющуюся логику в отдельные блоки. Они делают код аккуратнее, уменьшают дублирование и позволяют псевдо-инкапсуляцию. Синтаксис функций может выглядеть так:

```skript
function add-coins(p: player, amount: number):
    add {_amount} to {coins::%_p%}
    send "Вам выдали %{_amount}% монет." to {_p}
```

Ключевые аспекты:

* Параметры функции доступны как локальные переменные с префиксом `_` (`{_p}`, `{_amount}`).
* Функция может возвращать значение (в разных версиях Skript синтаксис `return` поддерживается).
* Параметры могут иметь значения по умолчанию.
* Примеры использования:

  ```skript
  set {_total} to total(1, 2, 3)
  ```

Пример функции суммирования:

```skript
function total(numbers: numbers) :: number:
    set {_sum} to 0
    loop {_numbers::*}:
        add loop-value to {_sum}
    return {_sum}
```

Пользовательские конструкции включают:

* **Сниппеты/шаблоны** - готовые блоки кода, которые удобно копировать.
* **Хуки/шаблоны событий** - функции-обёртки, которые вызываются в начале/конце событий.
* **Перегрузка** - Skript не всегда поддерживает множественные сигнатуры; будьте осторожны с одноимёнными функциями.

Сравнение с Python:

* В Python: `def func(x): return x*x`. В Skript - схожая идея, но иной синтаксис и другая модель именования локальных переменных (`_`).
* Отсутствие строгой типизации и декларации типов делает функции гибче, но может скрывать ошибки.

Практика и рекомендации:

* Выносите повторяемую логику в функции (даже простые действия - это лучше, чем дублировать).
* Ограничивайте побочные эффекты - функции, которые изменяют глобальные переменные, сложнее тестировать.
* Используйте осмысленные имена и комментарии (операторы `#`), чтобы сделать API понятным для других администраторов сервера.

---

# Команды (commands) - как создавать команды для игроков

Skript значительно упрощает создание команд - достаточно объявить `command /name:` и прописать `trigger:`. Вот минимальный пример:

```skript
command /greet [<player>]:
    aliases: /hello
    permission: myplugin.greet
    trigger:
        if arg-1 is set:
            send "Привет, %arg-1%!" to player
        else:
            send "Привет, %player%!" to player
```

Особенности:

* `arg-1`, `arg-2`, ... - позиционные аргументы команды.
* В синтаксисе команды можно указывать типы аргументов: `<player>`, `<number>`, `<text>`, `<item>` - Skript попытается распарсить аргументы в нужный тип.
* `aliases:` задаёт альтернативные имена команды.
* `permission:` ограничивает доступ к команде по правам.
* `cooldown:` (в некоторых версиях) позволяет задать задержку между вызовами команды.
* Команда может быть вызвана как игроком, так и с консоли; используйте `if executor is player` чтобы отличать вызовы.

Пример команды с передачей предмета:

```skript
command /giveitem <item> [<player>]:
    permission: myplugin.give
    trigger:
        give arg-1 to arg-2 parsed as player
        send "Предмет %arg-1% выдан." to player
```

Советы:

* Валидация аргументов: всегда проверяйте на `is set` и корректность типа, иначе команда может вести себя неожиданно.
* Для сложных команд выносите логику в функцию.
* Логируйте важные команды (например, выдачи денег/предметов) - это упрощает отладку и аудит.

Сравнение с Python/CLI:

* В CLI-приложениях Python вы парсите `sys.argv` или используете `argparse`. В Skript большинство парсинга делает система за вас, если вы явно укажете типы аргументов в определении команды.

---

# Выражения, операции и математические аналогии

Skript поддерживает базовые арифметические операции и выражения. Выражения - это комбинации переменных, литералов и операций, которые дают результат (число, строку и т. д.).

Арифметика:

```skript
set {_a} to 5
set {_b} to {_a} * 2 + 10 / (3 - 1)
```

Skript выполняет стандартные операции `+`, `-`, `*`, `/`, `%` (остаток) и скобки для определения приоритета.

Строковые операции:

* Конкатенация обычно выполняется при составлении строк через `%variable%` или явно - Skript автоматически подставляет значения.
* Форматирование: `send "У игрока %{_coins}% монет"`.

Логические операции: `and`, `or`, `not`.

Математические аналогии:

* Переменные как неизвестные в уравнениях: `{x}` может хранить любое значение, вы решаете уравнения его присваивания.
* Цепочные сравнения `1 < x < 10` прямо соответствуют математической записи неравенств.
* Функции над списками (`sum`, `avg`, если доступны через аддон или реализованы вручную) - аналог агрегатных операций в математике и статистике.

Пример суммирования списка вручную:

```skript
function sumList(nums: numbers) :: number:
    set {_sum} to 0
    loop {_nums::*}:
        add loop-value to {_sum}
    return {_sum}
```

Сравнение с Python:

* Python:

  ```python
  total = sum([1,2,3])
  ```
* Skript эквивалент - либо через аддон, либо как функция выше.

Практические замечания:

* Skript не предназначен для тяжёлых численных вычислений - если вам нужны сложные алгоритмы, лучше реализовать их на Java или в отдельном модуле.
* Внимательно следите за типами данных (число vs строка) при выполнении арифметики - автоматические приведения могут привести к неожиданностям.

---

# Работа с игроками и игровым миром (локации, предметы, сущности)

Skript тесно интегрирован с объектами Minecraft: игроки, предметы, локации, блоки и сущности - все это первоклассные типы. Часто вам нужны операции вроде дать предмет, телепортировать игрока, проверить блок в координатах или управлять инвентарём.

Основные операции:

* **Игроки**:

  ```skript
  teleport player to spawn
  give diamond to player
  send "Привет" to player
  ```

  Контекстные переменные: `%player%` (внутри `on join`), `loop-player` (в циклах), `arg-1` (в командах).

* **Локации**:

  ```skript
  set {home::%player%} to location of player
  teleport player to {home::%player%}
  ```

  Локация - комплексный тип: мир + координаты + направление. Можно сохранять локации в переменные и восстанавливать их.

* **Предметы**:

  ```skript
  give 5 diamond to player
  clear player's inventory
  set slot 1 of player's inventory to diamond sword named "Excalibur"
  ```

* **Сущности (entities)**:

  ```skript
  loop all entities in radius 10 around player:
      if loop-entity is zombie:
          damage loop-entity by 5
  ```

* **Блоки**:

  ```skript
  set block at location 100,64,100 in world "world" to stone
  broadcast "Променял блок!" 
  ```

Практические примеры:

* Система хомов:

  ```skript
  command /sethome:
      trigger:
          set {home::%player's uuid%} to location of player
          send "Дом сохранён."

  command /home:
      trigger:
          teleport player to {home::%player's uuid%}
  ```
* Защита от гриферов: перехват `on break` и `cancel event` если у игрока нет права.

Опасности и советы:

* Изменение миров и большого количества блоков за один обработчик может сильно нагружать сервер - дробите операции по таймеру (`every`) или батчами.
* При работе с сущностями используйте фильтры (`if loop-entity is zombie`) чтобы не обрабатывать лишние объекты.
* Для постоянного хранения данных используйте уникальные ключи (UUID игроков), чтобы обновления не пересекались.

---

# Отладка, производительность и лучшие практики

Skript прост в написании, но при масштабировании проектов важно следить за производительностью и поддерживаемостью.

Отладка:

* Используйте `broadcast` или `send` для вывода промежуточных значений:

  ```skript
  send "DEBUG: value = %{_val}%" to player
  ```
* Логируйте события - особенно выдачу привилегий, денег, предметов.
* Для сложных сценариев временно отключайте скрипты и тестируйте по частям.

Производительность:

* Избегайте тяжёлых циклов в `on`-событиях (например, `loop all blocks in radius 50 of player` внутри `on move` может убить сервер).
* Используйте периодические задачи (`every`) для фоновых работ и разбивайте долгие операции на небольшие шаги.
* Кешируйте данные вместо частых чтений/записей в глобальные переменные, если это оправдано.
* Минимизируйте использование глобальных синхронизированных структур, особенно при высоком числе игроков.

Лучшие практики по коду:

* Структурируйте код: разделяйте скрипты на файлы по функционалу (home, economy, admin).
* Используйте функции для повторяющейся логики.
* Документируйте переменные (`# Комментарий`) и формат хранения (например `{home::%uuid%}`).
* Придерживайтесь соглашений об именах: `{_localVar}`, `{globalVar}`, `{list::*}` и т. д.

Безопасность:

* Проверяйте права `permission` в командах и в критичных местах логики.
* Не доверяйте входным данным: аргументы команд всегда валидируйте.
* При выдаче предметов/денег логируйте операции.

Когда переходить на Java:

* Если вам нужна высокая производительность, сложные алгоритмы или tight-интеграция с API, подумайте о реализации на Java/Spigot, а Skript использовать для быстрых фич/прототипов.

---

# Краткие примеры: готовые мини-скрипты и сравнения с Python

**Пример 1 - Приветствие при входе** (Skript):

```skript
on join:
    send "Добро пожаловать на сервер, %player%!" to player
    if player has permission "vip":
        send "Спасибо, что поддерживаете сервер!" to player
```

Аналог на Python (в веб-контексте): регистрировать обработчик и отправлять сообщение пользователю при подключении - концепт тот же: событие -> обработчик -> действие.

**Пример 2 - Простая экономическая функция** (Skript):

```skript
function add-money(p: player, amount: number):
    add {_amount} to {balance::%p's uuid%}
    send "Вам выдано %{_amount}% монет." to {_p}
```

Сравнение с Python:

```python
balances = {}

def add_money(uuid, amount):
    balances[uuid] = balances.get(uuid, 0) + amount
```

Разница - в Skript вы используете глобальные переменные с ключами, а в Python - словари. Логика идентична.

**Пример 3 - Команда /sethome и /home** (Skript):

```skript
command /sethome:
    trigger:
        set {home::%player's uuid%} to location of player
        send "Дом сохранён."

command /home:
    trigger:
        if {home::%player's uuid%} is set:
            teleport player to {home::%player's uuid%}
        else:
            send "Дом не установлен."
```

Эти примеры демонстрируют, как привычные задачи (CRUD-хранилища, команды, события) реализуются в Skript с минимальными усилиями.
